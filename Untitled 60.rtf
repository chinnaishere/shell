{\rtf1\ansi\ansicpg1252\cocoartf1265
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww17040\viewh14600\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 #include <stdio.h>\
#include <stdlib.h>\
#include <string.h>\
#include <unistd.h>\
#include <sys/types.h>\
#include <sys/wait.h>\
\
#define BUFSIZE 1000\
\
char formatBuffer[10];\
\
void exitShell(void);\
void cdShell(void);\
\
struct Builtins \{ \
    char *name; /* name of function */ \
    int (*f)(); /* function to execute for the built-in command */ \
\};\
\
typedef struct Token \{\
    int start;\
    int len;\
\} Token;\
\
typedef struct Command \{\
    char *cmd; //cmd to call\
    char *args; //args to pass to that call\
\} Command;\
\
int parse(char *buffer, int buflen, Token *tokens, int *tokensSize, int argc, char **argv)\
\{\
    int i, dQuoteOpen=0, sQuoteOpen=0;\
    int start = -1; // start of token, end of token will be i, -1 means need a starting point\
    for (i = 0; i < buflen; ++i) \
    \{\
        if (buffer[i] == '"' && !sQuoteOpen) \{\
            if (dQuoteOpen) \{ //closing double quote found, make token\
                tokens[*tokensSize].start = start;\
                tokens[*tokensSize].len = i - start;\
                ++(*tokensSize);\
                dQuoteOpen = 0;\
                start = -1;\
            \} else \{\
                dQuoteOpen = 1;\
                start = ++i; // assuming there won't be 2 double quotes back to back, i = '"', i+1=next char\
            \} \
        \} else if (buffer[i] == '\\'' && !dQuoteOpen) \{\
            if (sQuoteOpen) \{ //closing singe quote found, make token\
                tokens[*tokensSize].start = start;\
                tokens[*tokensSize].len = i - start;\
                ++(*tokensSize);\
                sQuoteOpen = 0;\
                start = -1;\
            \} else \{\
                sQuoteOpen = 1;\
                start = ++i; // assuming there won't be 2 double quotes back to back, i = '"', i+1=next char\
            \}\
        \} else \{ //any character or space\
            if (sQuoteOpen || dQuoteOpen) \
                continue;\
            if (start == -1) \{\
                if (buffer[i] == ' ') //space, continue onto next char, still looking for start\
                    continue;\
                start = i; //nonspace, now our starting point\
                if (buffer[i] == '|') \{\
                    tokens[*tokensSize].start = start;\
                    tokens[*tokensSize].len = 1;\
                    ++(*tokensSize);\
                    start = -1;\
                \}\
            \} else \{ //not looking for start, token is already building\
                if (buffer[i] == ' ' || buffer[i] == '|') \{ //space or pipe found, token completed\
                    tokens[*tokensSize].start = start;\
                    tokens[*tokensSize].len = i - start;\
                    ++(*tokensSize);\
                    start = -1;\
                    if (buffer[i] == '|') //dec i, loop incs and reruns on pipe. (less code)\
                        --i;\
                \}\
            \}\
        \}\
    \}\
\
    if (start > -1) \{ //loop ended with last token still not added to array\
        if (dQuoteOpen || sQuoteOpen)\
            return 1; //error\
        tokens[*tokensSize].start = start;\
        tokens[*tokensSize].len = i - start;\
        ++(*tokensSize);\
    \}\
\
\
    return 0;\
\}\
\
char *format(Token *token)\
\{\
    formatBuffer[0] = '%';\
    formatBuffer[1] = '.';\
    formatBuffer[2] = '\\0';\
    char len[5];\
    sprintf(len, "%d", token->len);\
    strcat(formatBuffer, len);\
    strcat(formatBuffer, "s\\n");\
    return formatBuffer;\
\}\
\
void tokensToCommands(char *buffer, Token *tokens, int tokensSize, Command *cmds, int *cmdsSize)\
\{\
    int start = 0;\
    int i;\
    for (i = 0; i < tokensSize; ++i) \{\
        if (tokens[i].len == 1 && buffer[tokens[i].start] == '|') \{\
            char *tok = (char *)malloc(sizeof(char)*(tokens[start].len + 1));\
            tok[0] = '\\0';\
            strncat(tok, buffer + tokens[start].start, tokens[start].len);\
            cmds[*cmdsSize].cmd = tok;\
            \
            int j, argsize = 0;\
            for (j = start+1; j < i; ++j) //go through all tokens up to the pipe which is in cell i, count size to malloc\
                argsize += tokens[j].len + 1; //plus 1 for space and/or nul terminator\
            tok = (char *)malloc(sizeof(char)*(argsize));\
            tok[0] = '\\0';\
            for (j = start+1; j < i; ++j) \{ //go through all tokens up to the pipe which is in cell i\
                strncat(tok, buffer + tokens[j].start, tokens[j].len);\
                if (j < i-1)\
                    strncat(tok, " ", 1);\
            \}\
\
            cmds[*cmdsSize].args = tok;\
            ++(*cmdsSize);\
            start = ++i;\
        \}\
    \}\
\
    //last command, not going  to be "commandized" in loop\
    char *tok = (char *)malloc(sizeof(char)*(tokens[start].len + 1));\
    tok[0] = '\\0';\
    strncat(tok, buffer + tokens[start].start, tokens[start].len);\
    cmds[*cmdsSize].cmd = tok;\
\
    int j, argsize = 0;\
    for (j = start+1; j < i; ++j) //go through all tokens up to the pipe which is in cell i, count size to malloc\
        argsize += tokens[j].len + 1; //plus 1 for space and/or nul terminator\
    tok = (char *)malloc(sizeof(char)*(argsize + 1));\
    tok[0] = '\\0';\
    for (j = start+1; j < i; ++j) \{//go through all tokens up to the pipe which is in cell i\
        strncat(tok, buffer + tokens[j].start, tokens[j].len);\
        if (j < i-1)\
            strncat(tok, " ", 1);\
    \}\
\
    cmds[*cmdsSize].args = tok;\
    ++(*cmdsSize);\
\
\}\
\
\
/*set command and token memory to null for next userinput*/\
void reset(Command cmds[50], Token tokens[50])\{\
    for(int k = 0; k <= 49; k++)\{\
        cmds[k].cmd = NULL;\
        cmds[k].args = NULL;\
        tokens[k].start = 0;\
        tokens[k].len = 0;\
    \}\
\}\
\
int main(int argc, char **argv)\{\
    void looppipe(Command cmds[50], int cmdcount);\
    //create builtins\
    struct Builtins builtins[2];\
    builtins[0].name = "cd";\
    builtins[1].name = "exit";\
\
    //create tokens array\
    Token tokens[50];\
    int tokensSize = 0; //Number of elements in Token array\
\
    //create commands array\
    Command cmds[50];\
    int cmdsSize = 0;\
\
    char buffer[BUFSIZE];\
    while (1)\{\
        fgets(buffer, BUFSIZE, stdin);\
        int buflen = strlen(buffer)-1;\
        buffer[buflen] = '\\0';\
\
        if (parse(buffer, buflen, tokens, &tokensSize, argc, argv) > 0) \{\
            fprintf(stderr, "Failed on parsing arguments, invalid input.\\n");\
            return 1;\
        \}\
\
        tokensToCommands(buffer, tokens, tokensSize, cmds, &cmdsSize);\
        printf("command size: %d\\n",cmdsSize);\
\
        tokensSize = 0;\
\
        //here check builtins cd/exit for, temporary fix for exit\
        if(strncmp(cmds[0].cmd,"exit",4) == 0)\{\
            exit(0);\
        \}\
\
        looppipe(cmds, cmdsSize);\
\
        reset(cmds,tokens);\
        cmdsSize = 0;\
        tokensSize = 0;\
        \}\
    exit(0);\
\
\}\
\
\
void looppipe(Command cmds[50], int cmdcount)\{\
    int reading[cmdcount];\
    int writing[cmdcount];\
    pid_t pid;\
    int fd_in = 0;\
    int currcmd = 0;\
\
    int p;\
    for(p=0; p < cmdcount; p++)\{\
        reading[p] = -1;\
        writing[p] = -1;\
    \}\
\
    int j;\
    for(j=0; j < cmdcount-1; j++)\{\
        int fileds[2];\
        pipe(fileds);\
        reading[j+1] = fileds[0];\
        writing[j] = fileds[1];\
    \}\
    int i = 0;\
    for(i = 0; i < cmdcount;i++)\{\
        pid_t childpid;\
        int status;\
        childpid=fork();\
\
        if (childpid >= 0)\{\
            if (childpid == 0)\{               \
                if(writing[i] != -1)\{\
                    dup2(writing[i],1);\
                    close(writing[i]);\
                \}\
\
                if(reading[i] != -1)\{\
                    dup2(reading[i],0);\
                    close(reading[i]);\
                \}\
\
                int h;\
                for(h = 0; h < cmdcount; h++)\{\
                    close(writing[h]);\
                    close(reading[h]);\
                \}\
                printf("about to execute: %s",cmds[i].cmd);\
                execvp(cmds[i].cmd,&cmds[i].args);\
            \}\
            else\{\
                wait(&status);\
                int m;\
                for(m = 0; m < cmdcount; m++)\{\
                    if( writing[m] != -1) close(writing[m]);\
                    if( reading[m] != -1) close(reading[m]);\
                \}\
            \}\
        \}\
        else\{\
             perror("fork"); \
             continue;\
        \}\
    \}\
\}}